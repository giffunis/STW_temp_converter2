// Generated by CoffeeScript 1.9.0
(function() {
  var Blanket, log, parseAndModify;

  parseAndModify = require('falafel');

  log = require('./log');

  Blanket = (function() {
    function Blanket() {
      this._trackingArraySetup = [];
      this._branchingArraySetup = [];
      this.linesToAddTracking = ['ExpressionStatement', 'BreakStatement', 'ContinueStatement', 'VariableDeclaration', 'ReturnStatement', 'ThrowStatement', 'TryStatement', 'FunctionDeclaration', 'IfStatement', 'WhileStatement', 'DoWhileStatement', 'ForStatement', 'ForInStatement', 'SwitchStatement', 'WithStatement'];
      this.linesToAddBrackets = ['IfStatement', 'WhileStatement', 'DoWhileStatement', 'ForStatement', 'ForInStatement', 'WithStatement'];
      this.coverageInfo = {};
      this._options = {
        reporter: null,
        adapter: null,
        filter: null,
        customVariable: null,
        loader: null,
        ignoreScriptError: false,
        existingRequireJS: false,
        autoStart: false,
        timeout: 180,
        ignoreCors: false,
        branchTracking: false,
        sourceURL: false,
        debug: false,
        engineOnly: false,
        testReadyCallback: null,
        commonJS: false,
        instrumentCache: false,
        modulePattern: null
      };
    }

    Blanket.prototype._extend = function(dest, source) {
      var key, value, _results;
      if (source) {
        _results = [];
        for (key in source) {
          value = source[key];
          if (dest[key] instanceof Object && typeof dest[key] !== 'function') {
            _results.push(this._extend(dest[key], source[key]));
          } else {
            _results.push(dest[key] = value);
          }
        }
        return _results;
      }
    };

    Blanket.prototype.getCovVar = function() {
      var opt;
      opt = this.options('customVariable');
      if (opt) {
        log.debug("BLANKET-Using custom tracking variable:", opt);
        return opt;
      }
      return "_$jscoverage";
    };

    Blanket.prototype.options = function(key, value) {
      if (typeof key !== 'string') {
        return this._extend(this._options, key);
      } else if (typeof value === 'undefined') {
        return this._options[key];
      } else {
        return this._options[key] = value;
      }
    };

    Blanket.prototype.normalizeBackslashes = function(str) {
      return str.replace(/\\/g, '/');
    };

    Blanket.prototype.matchPattern = function(filename, pattern) {
      var cwdRegex, ex, mods, pattenArr, regex;
      cwdRegex = this.options('cwdRegex');
      if (cwdRegex && !cwdRegex.test(filename)) {
        return false;
      }
      if (typeof pattern === 'string') {
        if (pattern.indexOf('[') === 0) {
          pattenArr = pattern.slice(1, pattern.length - 1).split(',');
          return pattenArr.some((function(_this) {
            return function(elem) {
              return _this.matchPattern(filename, _this.normalizeBackslashes(elem.slice(1, -1)));
            };
          })(this));
        } else if (pattern.indexOf('//') === 0) {
          ex = pattern.slice(2, pattern.lastIndexOf('/'));
          mods = pattern.slice(pattern.lastIndexOf('/') + 1);
          regex = new RegExp(ex, mods);
          return regex.test(filename);
        } else {
          return filename.indexOf(this.normalizeBackslashes(pattern)) > -1;
        }
      } else if (Array.isArray(pattern)) {
        return pattern.some((function(_this) {
          return function(elem) {
            return filename.indexOf(_this.normalizeBackslashes(elem)) > -1;
          };
        })(this));
      } else if (pattern instanceof RegExp) {
        return pattern.test(filename);
      } else if (typeof pattern === 'function') {
        return pattern(filename);
      } else {
        throw Error("Bad file instrument indicator.  Must be a string, regex, function, or array.");
      }
    };

    Blanket.prototype.instrument = function(config, next) {
      var inFile, inFileName, instrumented, sourceArray;
      inFile = config.inputFile;
      inFileName = config.inputFileName;
      if (this.options('instrumentCache') && sessionStorage && sessionStorage.getItem('blanket_instrument_store-' + inFileName)) {
        log.debug("BLANKET-Reading instrumentation from cache: ", inFileName);
        return next(sessionStorage.getItem("blanket_instrument_store-" + inFileName));
      } else {
        sourceArray = this._prepareSource(inFile);
        this._trackingArraySetup = [];
        inFile = inFile.replace(/^\#\!.*/, "");
        instrumented = parseAndModify(inFile, {
          loc: true,
          comment: true
        }, this._addTracking(inFileName));
        instrumented = this._trackingSetup(inFileName, sourceArray) + instrumented;
        if (this.options("sourceURL")) {
          instrumented += "\n//@ sourceURL=" + inFileName.replace("http://", "");
        }
        log.debug("BLANKET-Instrumented file: ", inFileName);
        if (this.options("instrumentCache") && sessionStorage) {
          log.debug("BLANKET-Saving instrumentation to cache: ", inFileName);
          sessionStorage.setItem("blanket_instrument_store-" + inFileName, instrumented);
        }
        return next(instrumented);
      }
    };

    Blanket.prototype._prepareSource = function(source) {
      return source.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/(\r\n|\n|\r)/gm, "\n").split('\n');
    };

    Blanket.prototype._trackingSetup = function(filename, sourceArray) {
      var branches, covVar, intro, sourceString;
      branches = this.options("branchTracking");
      sourceString = sourceArray.join("',\n'");
      intro = '';
      covVar = this.getCovVar();
      intro += "if (typeof " + covVar + " === 'undefined') " + covVar + " = {};\n";
      if (branches) {
        intro += "var _$branchFcn=function(f,l,c,r){ ";
        intro += "if (!!r) { ";
        intro += covVar + "[f].branchData[l][c][0] = " + covVar + "[f].branchData[l][c][0] || [];";
        intro += covVar + "[f].branchData[l][c][0].push(r); }";
        intro += "else { ";
        intro += covVar + "[f].branchData[l][c][1] = " + covVar + "[f].branchData[l][c][1] || [];";
        intro += covVar + "[f].branchData[l][c][1].push(r); }";
        intro += "return r;};\n";
      }
      intro += "if (typeof " + covVar + "['" + filename + "'] === 'undefined'){";
      intro += covVar + "['" + filename + "']=[];\n";
      if (branches) {
        intro += covVar + "['" + filename + "'].branchData=[];\n";
      }
      intro += covVar + "['" + filename + "'].source=['" + sourceString + "'];\n";
      this._trackingArraySetup.sort(function(a, b) {
        return parseInt(a, 10) > parseInt(b, 10);
      }).forEach(function(item) {
        return intro += covVar + "['" + filename + "'][" + item + "]=0;\n";
      });
      if (branches) {
        this._branchingArraySetup.sort(function(a, b) {
          return a.line > b.line;
        }).sort(function(a, b) {
          return a.column > b.column;
        }).forEach(function(item) {
          if (item.file === filename) {
            intro += "if (typeof " + covVar + "['" + filename + "'].branchData[" + item.line + "] === 'undefined'){\n";
            intro += covVar + "['" + filename + "'].branchData[" + item.line + "]=[];\n";
            intro += "}";
            intro += covVar + "['" + filename + "'].branchData[" + item.line + "][" + item.column + "] = [];\n";
            intro += covVar + "['" + filename + "'].branchData[" + item.line + "][" + item.column + "].consequent = " + JSON.stringify(item.consequent) + ";\n";
            return intro += covVar + "['" + filename + "'].branchData[" + item.line + "][" + item.column + "].alternate = " + JSON.stringify(item.alternate) + ";\n";
          }
        });
      }
      intro += "}";
      return intro;
    };

    Blanket.prototype._blockifyIf = function(node) {
      var bracketsExistAlt, bracketsExistObject;
      if (this.linesToAddBrackets.indexOf(node.type) > -1) {
        bracketsExistObject = node.consequent || node.body;
        bracketsExistAlt = node.alternate;
        if (bracketsExistAlt && bracketsExistAlt.type !== 'BlockStatement') {
          bracketsExistAlt.update('{\n' + bracketsExistAlt.source() + '}\n');
        }
        if (bracketsExistObject && bracketsExistObject.type !== 'BlockStatement') {
          return bracketsExistObject.update('{\n' + bracketsExistObject.source() + '}\n');
        }
      }
    };

    Blanket.prototype._trackBranch = function(node, filename) {
      var col, line, updated;
      line = node.loc.start.line;
      col = node.loc.start.column;
      this._branchingArraySetup.push({
        line: line,
        column: col,
        file: filename,
        consequent: node.consequent.loc,
        alternate: node.alternate.loc
      });
      updated = "_$branchFcn" + "('" + filename + "'," + line + "," + col + "," + node.test.source() + ")?" + node.consequent.source() + ":" + node.alternate.source();
      return node.update(updated);
    };

    Blanket.prototype._addTracking = function(filename) {
      var covVar;
      covVar = this.getCovVar();
      return (function(_this) {
        return function(node) {
          _this._blockifyIf(node);
          if (_this.linesToAddTracking.indexOf(node.type) > -1 && node.parent.type !== 'LabeledStatement') {
            _this._checkDefs(node, filename);
            if (node.type === 'VariableDeclaration' && (node.parent.type === 'ForStatement' || node.parent.type === 'ForInStatement')) {
              return;
            }
            if (node.loc && node.loc.start) {
              node.update(covVar + "['" + filename + "'][" + node.loc.start.line + "]++;\n" + node.source());
              return _this._trackingArraySetup.push(node.loc.start.line);
            } else {
              throw new Error("The instrumenter encountered a node with no location: " + Object.keys(node));
            }
          } else if (_this.options("branchTracking") && node.type === 'ConditionalExpression') {
            return _this._trackBranch(node, filename);
          }
        };
      })(this);
    };

    Blanket.prototype._checkDefs = function(node, filename) {
      if (node.type === 'ExpressionStatement' && node.expression && node.expression.left && !node.expression.left.object && !node.expression.left.property && node.expression.left.name === this.getCovVar()) {
        throw new Error("Instrumentation error, you cannot redefine the coverage variable in  " + filename + ":" + node.loc.start.line);
      }
    };

    Blanket.prototype.setupCoverage = function() {
      this.coverageInfo.instrumentation = 'blanket';
      return this.coverageInfo.stats = {
        suites: 0,
        tests: 0,
        passes: 0,
        pending: 0,
        failures: 0,
        start: new Date()
      };
    };

    Blanket.prototype._checkIfSetup = function() {
      if (!this.coverageInfo.stats) {
        throw new Error("You must call blanket.setupCoverage() first.");
      }
    };

    Blanket.prototype.onTestStart = function() {
      log.debug("BLANKET-Test event started");
      this._checkIfSetup();
      this.coverageInfo.stats.tests++;
      return this.coverageInfo.stats.pending++;
    };

    Blanket.prototype.onTestDone = function(total, passed) {
      this._checkIfSetup();
      if (passed === total) {
        this.coverageInfo.stats.passes++;
      } else {
        this.coverageInfo.stats.failures++;
      }
      return this.coverageInfo.stats.pending--;
    };

    Blanket.prototype.onModuleStart = function() {
      this._checkIfSetup();
      return this.coverageInfo.stats.suites++;
    };

    Blanket.prototype.onTestsDone = function() {
      log.debug("BLANKET-Test event done");
      this._checkIfSetup();
      this.coverageInfo.stats.end = new Date();
      if (!this.options("branchTracking")) {
        delete global[this.getCovVar()].branchFcn;
      }
      return this.options("reporter").call(this, this.coverageInfo);
    };

    return Blanket;

  })();

  exports.blanket = new Blanket();

}).call(this);
